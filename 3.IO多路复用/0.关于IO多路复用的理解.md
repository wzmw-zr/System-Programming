# 关于IO多路复用的理解

## 一、IO多路复用的含义

IO多路复用：**==指的是同一个进程(线程)可以处理多个IO数据流。==**

多线程+池模型：**每个线程处理一个IO流。**

> 多线程：受限于CPU，响应能力受到限制，线程太多调度困难，响应时间大幅延长
>
> 阻塞：响应能力受限
>
> 非阻塞：需要循环检测



## 二、IO多路复用的适用场景

IO多路复用适用于**需要保持大量闲置长连接，并且非计算密集型任务的业务场景，例如聊天室。**好处是**可以避免不断地创建新的进程或者线程**，导致系统资源浪费。而计算密集型任务耗时长，会大大降低系统处理其他连接的响应速度。

当然，使用IO多路复用+单线程/进程也有其他好处：节省了切换调度对象的时间，也避免了多线程，多进程的并发问题。

**不过，在极限IO压力下，不管是IO多路复用还是线程池模型都抗不住，这种时候就要扩容了。**



## 三、IO多路复用—select，poll，epoll之间的区别

select，poll，epoll可以同时监视多个流的IO事件，在空闲的时候会阻塞当前线程，当有一个或多个流的IO事件发生时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流，不过epoll只轮询真正发生事件的流，三者都可以一次性顺序处理就绪的流。

+ select：服务端一直在轮询、监听如果有客户端链接上来就创建一个连接放到数组A中，继续轮询这个数组，如果在轮询的过程中有客户端发生IO事件就去处理；**select只能监视1024个连接(一个进程只能创建1024个文件)，并且每次要三次for循环进行检查，而且存在线程安全问题**；
+ poll：在select做了许多修复，**比如不限制监测的连接数，每次只要一次for循环；但是也有线程安全问题**；
+ epoll：也是监测IO事件，但是如果发生IO事件，它会告诉你是哪个连接发生了事件，就不用再轮询访问。而且它**是线程安全的，并且每次只需处理实际就绪的文件描述符，但是只有linux平台支持**；

**epoll效率最高。**