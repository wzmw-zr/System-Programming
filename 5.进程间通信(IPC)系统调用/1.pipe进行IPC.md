# pipe进行`IPC`

## 一、管道`IPC`的实例

**在Shell中使用管道实际上就是进程间通信**，将前一个进程的标准输出送给后一个进程的标准输入。

```bash
man ls | wc -l
```



## 二、管道`IPC`的特点

1. **管道只能是在父子进程、兄弟进程这些具有血缘关系的进程间通信。**
2. **管道需要在子进程创建之前就建立好。**
3. **==管道有着严格的读写文件描述符的区分，千万不能弄错！！！==**
4. **管道的`filedes`，0代表读，1代表写。**

> **==关于管道文件描述符的记忆，0文件描述符是标准输入，1文件描述符是标准输出，与之对应，0代表读，1代表写。==**

5. 管道只能单向通信，双向通信需要建立两个管道





## 三、pipe()—创建管道

pipe()系统调用用来创建管道：

```c
#include <unistd.h>

// fildes是读写描述符数组，0代表读，1代表写
int pipe(int fildes[2]);
// return 0 on success, or -1 on error
```

**==管道的注意点：pipe()的`fildes`数组中，0代表读，1代表写，这对于通信进程而言都是一致的。==**



## 四、管道的使用

**使用管道进行`IPC`时，我们只需要一个进程的写，另一个进程读，两个进程中==多余一端管道文件描述符需要先关闭，保证管道不会分叉，决定了管道只能单向通信==**，不然会影响后面的操作。



## 五、管道行为分析

### 1.读管道

+ 写端全部关闭——read读到0,相当于读到文件末尾
+ 写端没有全部关闭
  + 有数据——read读到数据
  + 无数据——read阻塞，**`fcntl`函数可以更改非阻塞**



### 2.写管道

+ 读管道全部关闭——产生一个`SIGPIPE`信号，程序异常终止
+ 读管道未全部关闭
  + 管道已满——write阻塞
  + 管道未满——write正常写入



