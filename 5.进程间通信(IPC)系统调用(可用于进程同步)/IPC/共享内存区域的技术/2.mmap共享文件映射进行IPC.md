# `mmap()`文件映射`IPC`

`mmap()`系统调用在调用进程的虚拟地址空间中创建一个新的映射。**也需要使用文件锁或者信号量来进行进程同步。**

**==`mmap()`的最主要用途还是用来进行存储映射IO，这样效率非常高，详情见11文件夹。==**



## 一、`mmap()`与`shm`的区别

**`shm`共享内存是将进程中的共享内存部分映射到了同一块物理内存中，==是在物理内存中创建了一块空间，让进程一起使用,速度最快。==**由于`shm`的数据保存在内存中，所以数据比较快，但是存储量不大。

一般而言，使用`shm`就足够了，而且速度很快。

`mmap`**==在磁盘上建立一个文件，每个进程地址空间中开辟出一块空间与这个文件进行映射。速度不及`shm`，但是也挺快了，且数据不会丢失。==**`mmap`的数据存在磁盘上，可以处理大文件。



## 二、`mmap()`—创建内存映射(共享磁盘数据)

`mmap()`系统调用的函数原型如下所示：

```c
#include <sys/mman.h>
// addr是指定的内存映射区域的在内存中的地址，使用NULL，内核会分配合适的地址
// len内存映射区的大小,也可以只是一个结构体的大小
// prot：内存映射区的读、写、执行属性。PROT_READ, PROT_WRITE等
// flags:标注内存映射区的共享属性，MAP_SHARED, MAP_PRIVATE
// MAP_SHARED：对映射区的修改会反映到磁盘上
// MAP_PRIVATE：对映射区的修改不会反映到磁盘上
//fd用于内存映射的文件描述符
// off：偏移量，需要是4k的整数倍。
void *mmap(void *addr, size_t len, int prot, int flags,
           int fildes, off_t off);
// 成功时返回映射区首地址，失败返回MAP_FAILED((void *)-1)
```

**==一旦映射成功就可以关闭文件描述符而不会影响映射。==**



## 三、`munmap()`—取消内存映射

`munmap()`系统调用用来取消内存映射，其函数原型如下：

```c
#include <sys/mman.h>
// addr是内存映射区的地址，len是内存映射区的大小
int munmap(void *addr, size_t len);
// return 0 on success, or -1 on error
```



## 四、注意事项

1. **不可以使用大小为0的文件，即使是新建的文件，也是需要进行扩充的**
3. **映射区的操作权限一定要小于等于打开文件的权限**
3. 打开文件建议是读写操作都允许
4. 文件偏移量建议是`4k`的整数倍，**但是系统会自动分配页大小的整数倍空间**



## 五、具体的使用例子

![img1](./mmap1.png)

**情形一：**一个文件的大小是5000字节，`mmap`函数从一个文件的起始位置开始，映射5000字节到虚拟内存中。

**分析：**因为单位物理页面的大小是4096字节，虽然被映射的文件只有5000字节，但是对应到进程虚拟地址区域的大小需要满足整页大小，因此`mmap`函数执行后，实际映射到虚拟内存区域8192个 字节，5000~8191的字节部分用零填充。



**情形二：一个文件的大小是5000字节，`mmap`函数从一个文件的起始位置开始，映射15000字节到虚拟内存中，即映射大小超过了原始文件的大小。**

分析：**由于文件的大小是5000字节，和情形一一样，其对应的两个物理页。==那么这两个物理页都是合法可以读写的，只是超出5000的部分不会体现在原文件中。==**由于程序要求映射15000字节，而文件只占两个物理页，**因此8192字节~15000字节都不能读写，操作时会返回异常。**



**情形三：一个文件初始大小为0，使用`mmap`操作映射了1000*4K的大小，即1000个物理页大约`4M`字节空间，`mmap`返回指针`ptr`。**

分析：如果**在映射建立之初，就对文件进行读写操作，由于文件大小为0，并没有合法的物理页对应，如同情形二一样，会返回`SIGBUS`错误。**

但是如果**，每次操作`ptr`读写前，先增加文件的大小，那么`ptr`在文件大小内部的操作就是合法的。**例如，文件扩充4096字节，`ptr`就能操作`ptr ~ [ (char)ptr + 4095]`的空间。**只要文件扩充的范围在1000个物理页（映射范围）内，`ptr`都可以对应操作相同的大小。**

这样，方便随时扩充文件空间，随时写入文件，不造成空间浪费。



简单的代码例子：

```c
int main() {
    int fd = open("case.txt", O_CREAT | O_RDWR, 0666);
    // 截断文件用来改变文件大小
    ftruncate(fd, 100);
    char *word  = NULL;
    if ((word = mmap(NULL, 100, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)) == (void *) -1) {
        perror("mmap");
        exit(1);
    }
    scanf("%[^\n]s", word);
    getchar();
    close(fd);
    return 0;
}
```

**文件可以村结构体数据以实现结构化数据传输。**

