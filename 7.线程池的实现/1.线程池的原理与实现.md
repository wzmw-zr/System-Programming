# 线程池原理与实现

使用线程池的原因：频繁创建与销毁线程消耗时间较多，因此提前**设置好固定数量的线程用于处理事务，处理完事务后不销毁线程，而是用于处理下一次事务，节省了创建与销毁线程的开销。**

**==线程池需要注意各个线程之间竞争的资源是什么！！！==**

## 一、线程池的实现原理

**==线程池就是互斥量与条件变量结合使用的最好例子。==**

1. 进程创建的时候，**先创建有限个线程，这些线程用于处理事务**
2. **高并发时，线程数肯定是不够用的，所以==线程池需要扩容操作==**，但是线程占的是栈空间，所以**其数量上限会受到栈空间大小的限制**，**==我们需要自行设置线程数量的上限，当然线程数量也不能太小，需要设置线程数量下限==**
3. 要实现线程池的扩容操作，**需要总线程数量，当前运行线程数量作为判断依据**
4. 线程池的扩容操作需要提前预判好，**如使用线程达到总线程数量的80%，就需要进行扩容，同理，使用线程占比太小需要进行减容操作，一般使用线程数量小于总线程数量的20%就需要减容。**
5. 扩容与减容操作是批量增加与减少，比如一次性增加或者减少10个线程，**==这个操作需要一个管理线程来专门管理，管理线程池的扩容与减容，线程池的创建与销毁。==**



## 二、线程池结构体定义(简要)

线程池结构体的简要定义如下(可以额外增加项来表示更多信息)：

**==任务线程创建时，其回调函数的参数一定是线程池的指针，这样才可以实现线程同步。==**

```c
// 线程池中的线程任务结构体，不是线程的回调函数，这个是线程的任务函数，任务函数是会在线程的回调函数中调用，用于完成线程的任务。
typedef struct threadpool_task_t {
    void *(*function)(void *); // 这个是任务线程的处理任务而不是回调函数！！！，当然处理任务也可以参数和毁掉函数一样，回调函数一定是在线程创建时指定的！！！，毁掉函数的参数一定得包含线程池结构体，因为要使用互斥量与条件变量！！！
    void *arg; // 任务线程的处理任务的参数，泛型指针，因此可以传递任意类型的参数
} threadpool_task_t;

// 线程任务队列结构体，用于存储各个线程的的任务，自定义队列的结构操作，注意这是循环队列
typedef struct threadpool_task_queue {
    pthread_t *tids; // 线程id数组
    threadpool_task_t *task_queue; // 线程任务结构体数组
    int front, rear, cnt, size; // 队首，队尾，任务数量与最大任务数量
} threadpool_task_queue;

// 线程池结构体，需要自定义结构操作
typedef struct pthreadpool_t { 
    pthread_mutex_t mutex; // 用于锁住线程池结构体的互斥量
    pthread_mutex_t busy_thread_counter; // 用于锁住忙线程数量的结构体

    pthread_cond_t queue_full; // 判断任务线程队列是否满了
    pthread_cond_t queue_empty; // 判断任务线程队列是否为空

    pthread_t manager_tid; // 管理者线程的线程id

    int min_thread_num; // 线程数量下限
    int max_thread_num;// 线程数量上限
    int live_thread_num; // 存活的线程数量
    int busy_thread_num; // 正在工作的线程的数量
    int wait_thread_exit_num; // 准备销毁的线程的数量

    threadpool_task_queue task_thread__queue; // 任务线程队列

    int open; // 线程池是否可以使用
} pthreadpool_t;
```



## 三、线程池的工作流程

### 1.`main()`  函数大致工作流程

+ **创建线程池`pthreadpool_create()`，初始化相应的变量与结构体,==其管理者线程及工作线程都会创建并启动==**
+ **向线程池中添加任务线程`pthreadpool_add()`，添加线程任务`threadpool_task_t`**，并**==执行任务线程的回调函数`work_thread()`==**
+ **创建管理者线程，并执行管理者线程的回调函数`admin_thread()`**
+ **销毁线程池`pthreadpool_destroy()`**，释放结构体与变量的空间



### 2.工作线程`work_thread()`回调函数工作流程

`work_thread()`是**线程被创建后执行的函数，其参数是线程池结构体指针，因为需要用到互斥量与条件变量来完成线程同步**。在`work_thread()`函数中完成了线程同步之后进行线程的任务函数，这个任务函数及相应的参数存放在`threadpool_task_t *task_queue`队列中。

**==一定要注意任务线程的回调函数与任务函数的区别！！！回调函数是线程创建时执行的，任务函数是回调函数中的一部分！！！==**

**`work_thread()`需要将任务相应的任务函数出队，之后开始执行任务函数，为此，一定会在任务队列为空上阻塞，并且线程会在`thread_add_task()`之后唤醒相应的任务线程。**



### 3.`thread_add_task()`—向任务函数队列增加任务函数

`thread_add_task()`函数用于向任务函数队列增加任务函数，**增加了任务函数之后就意味着任务队列不为空，需要唤醒阻塞在没有任务的线程。**



### 4.管理者线程`admin_thread()`回调函数工作流程

管理者线程用来进行监控任务线程的数量情况，来决定是否需要扩容或者减容。**由于扩容与减容这些操作都是会有一定的提前量，所以，只需要间隔一段时间检测一次就行，比方说10s。**

如果指定了线程池关闭，那么管理者线程就要处理那些阻塞与正在工作的线程。